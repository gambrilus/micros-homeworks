# Домашнее задание к занятию «Микросервисы: принципы»

Вы работаете в крупной компании, которая строит систему на основе микросервисной архитектуры.
Вам как DevOps-специалисту необходимо выдвинуть предложение по организации инфраструктуры для разработки и эксплуатации.

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

Решение должно соответствовать следующим требованиям:
- маршрутизация запросов к нужному сервису на основе конфигурации,
- возможность проверки аутентификационной информации в запросах,
- обеспечение терминации HTTPS.

Обоснуйте свой выбор.

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

Решение должно соответствовать следующим требованиям:
- поддержка кластеризации для обеспечения надёжности,
- хранение сообщений на диске в процессе доставки,
- высокая скорость работы,
- поддержка различных форматов сообщений,
- разделение прав доступа к различным потокам сообщений,
- простота эксплуатации.

Обоснуйте свой выбор.

---


# Ответы

## Задача 1: API Gateway

| Название | Маршрутизация запросов <br/>нужному сервису<br/> на основе конфигурации | Возможность проверки <br/>аутентификационной информации<br/> в запросах | Обеспечение терминации HTTPS | Расширяемая архитектура плагинов |
|----------|:-----------------------------------------------------------------------:|:-----------------------------------------------------------------------:|:----------------------------:|:--------------------------------:|
| Kong     |                                    +                                    |                                    +                                    |              +               |                +                 |
| Tyk      |                                    +                                    |                                    +                                    |              +               |                +                 |
| Gloo     |                                    +                                    |                                    +                                    |              +               |                +                 |

#### Kong Gateway — для современных приложений на основе микросервисов.

Kong предоставляет множество функций управления API, и его шлюзовое решение существует в двух вариантах: продукт с открытым исходным кодом и лицензионный продукт с несколькими дополнительными функциями. Он также универсален с точки зрения развертывания, одним из которых являются готовые контейнеры Docker. Версия с открытым исходным кодом работает локально, но корпоративная версия также поддерживает реализацию гибридного облака.

Kong также известен своими многочисленными плагинами, как официальными, так и разработанными сообществом, которые позволяют при необходимости превратить ваш шлюз в платформу управления API полного цикла. Kong — надежный выбор шлюза, за исключением случаев, когда вы управляете устаревшими приложениями, он не может преобразовывать вызовы в форматы SOAP или XML.

#### Tyk Gateway — для разработки на уровне предприятия

Tyk может быть одним из наиболее доступных поставщиков, поскольку его шлюз имеет открытый исходный код и бесплатен даже с функциями корпоративного уровня. Простая интеграция также входит в философию Tyk — вы можете писать плагины на Python, JavaScript, Go и других языках и, конечно же, использовать плагины, созданные их растущим сообществом.

#### Gloo

Этот инструмент основан на Envoy Proxy — самом популярном прокси-сервере для Kubernetes — и пытается следовать современным и облачным традициям Envoy. У Gloo есть версия с открытым исходным кодом и корпоративная версия, обе они обеспечивают выбор среды, поддерживают бессерверные функции и обеспечивают маршрутизацию для gRPC.
Принимаются и конвертируются любые протоколы: REST, SOAP, gRPC, GraphQL и TCP.


## Задача 2: Брокер сообщений   

| Название | Поддержка кластеризации<br/> для обеспечения надёжности | Хранение сообщений на диске <br/>в процессе доставки | Высокая скорость работы | Поддержка различных форматов сообщений | Разделение прав доступа к различным потокам сообщений |                                            Простота эксплуатации                                             |
|----------|:-------------------------------------------------------:|:----------------------------------------------------:|:-----------------------:|:--------------------------------------:|:-----------------------------------------------------:|:------------------------------------------------------------------------------------------------------------:|
|  RabbitMQ    |                            +                            |                          -                           |            +            |                   +                    |                           +                           | Простое администрирование. У RabbitMQ удобная админка, где вы можете в режиме реального времени разбираться с тем, что происходит. Роутинги можно настраивать в процессе, переключая нагрузку и меняя правила обработки |
|  Apache Kafka      |                            +                            |                          +                           |            +            |                   +                    |                           +                           | Есть контейнерные решения + огромное количество разнообразных UI (Kafka UI, AKHQ, Confluent CC, CMAK и т.д.)                                                                                                             |
| 

В каких случаях использовать RabbitMQ

- Когда важна гибкость маршрутизации сообщений внутри системы. В таком случае он предоставляет инструменты для построения путей доставки данных и способен решить самые хитрые сценарии в организации потоков событий. 

- Если вам важен сам факт доставки сообщений и порядок их получения.

Когда использовать Kafka

- При конвейерной обработке данных. Kafka хорошо работает как общая шина для нескольких сервисов. Сервис что-то сделал, записал результат, следующий по конвейеру считал — записал, и так далее. В RabbitMQ это сработает хуже, так как конвейерность может нарушиться.
- При Event-driven architecture. В этом случае сообщения можно бродкастить всем необходимым сервисам, и нужные адресаты их получат. В RabbitMQ обязательно нужно знать, сколько у вас получателей. Особенно это актуально в микросервисном мире, где количество реплик сервиса меняется динамически.
- При использовании буфера для логов и метрик. Промежуточное хранилище для большого количества данных, где они будут сохранны и упорядочены.


